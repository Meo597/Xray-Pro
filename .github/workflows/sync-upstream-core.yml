name: Sync Upstream Xray-core

on:
  schedule:
    - cron: "0 9 * * 1"

  workflow_dispatch:

jobs:
  sync-upstream:
    runs-on: ubuntu-latest

    env:
      UPSTREAM_REPO: XTLS/Xray-core
      LATEST_BRANCH: Xray-core/latest
      FEATURE_BRANCH_PREFIX: Xray-core/feat/

    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.PAT_TOKEN }}

      - name: Setup Git config
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Check upstream stable release
        run: |
          # Fetch the latest non-prerelease release tag name
          latest_stable_tag=$(curl -s "https://api.github.com/repos/${{ env.UPSTREAM_REPO }}/releases?per_page=100" | \
            jq -r '.[] | select(.prerelease == false) | .tag_name' | head -1)

          if [ -z "$latest_stable_tag" ]; then
            echo "No stable release found."
            echo "LATEST_TAG=" >> $GITHUB_ENV
            exit 1
          fi

          echo "Latest stable tag: $latest_stable_tag"
          echo "LATEST_TAG=$latest_stable_tag" >> $GITHUB_ENV

      - name: Sync upstream stable release
        if: env.LATEST_TAG != ''
        run: |
          # Add upstream remote and fetch its tags
          git remote add upstream https://github.com/${{ env.UPSTREAM_REPO }}.git || true
          echo "Fetching upstream tags..."
          git fetch upstream --tags --force

          # Check if the target tag commit exists locally after fetch
          echo "Verifying target tag ${{ env.LATEST_TAG }} locally..."
          if git rev-parse --verify "refs/tags/${{ env.LATEST_TAG }}^{commit}" >/dev/null 2>&1; then
            TARGET_COMMIT=$(git rev-parse "refs/tags/${{ env.LATEST_TAG }}^{commit}")
            echo "Target tag ${{ env.LATEST_TAG }} points to commit: $TARGET_COMMIT"

            # Check if the branch exists on the *remote* (origin)
            REMOTE_BRANCH_REF="refs/heads/${{ env.LATEST_BRANCH }}"
            echo "Checking remote branch existence: origin/${{ env.LATEST_BRANCH }}"
            # Use git ls-remote to check the remote ref. Output format: <hash>\t<ref>
            REMOTE_COMMIT_INFO=$(git ls-remote origin $REMOTE_BRANCH_REF)

            CURRENT_REMOTE_COMMIT=""
            BRANCH_EXISTS_REMOTELY=false
            if [ -n "$REMOTE_COMMIT_INFO" ]; then
               # Extract hash from "<hash>\t<ref>" format
               CURRENT_REMOTE_COMMIT=$(echo "$REMOTE_COMMIT_INFO" | cut -f1)
               BRANCH_EXISTS_REMOTELY=true
               echo "Remote branch 'origin/${{ env.LATEST_BRANCH }}' exists and points to commit: $CURRENT_REMOTE_COMMIT"
            else
               echo "Remote branch 'origin/${{ env.LATEST_BRANCH }}' does not exist."
            fi

            # Now, decide action based on remote existence and commit hash comparison
            if $BRANCH_EXISTS_REMOTELY && [ "$CURRENT_REMOTE_COMMIT" == "$TARGET_COMMIT" ]; then
              echo "Remote branch 'origin/${{ env.LATEST_BRANCH }}' is already synced with tag '${{ env.LATEST_TAG }}'."
              echo "LATEST_UPDATED=false" >> $GITHUB_ENV
              exit 0
            elif $BRANCH_EXISTS_REMOTELY; then
              # Branch exists remotely but points to a different commit
              echo "Remote branch 'origin/${{ env.LATEST_BRANCH }}' needs update (Current: $CURRENT_REMOTE_COMMIT, Target: $TARGET_COMMIT)."
              echo "Forcing push to update remote branch..."
              # Force push the target commit to the remote branch ref
              if git push --force origin "$TARGET_COMMIT:$REMOTE_BRANCH_REF"; then
                echo "LATEST_UPDATED=true" >> $GITHUB_ENV
                exit 0
              else
                echo "Error: Failed to update remote branch 'origin/${{ env.LATEST_BRANCH }}'."
                echo "LATEST_UPDATED=false" >> $GITHUB_ENV
                exit 1
              fi
            else
              # Branch does not exist remotely
              echo "Remote branch 'origin/${{ env.LATEST_BRANCH }}' does not exist. Creating it..."
              # Push the target commit to create the new remote branch ref
              if git push origin "$TARGET_COMMIT:$REMOTE_BRANCH_REF"; then
                echo "LATEST_UPDATED=true" >> $GITHUB_ENV
                exit 0
              else
                echo "Error: Failed to create the new remote branch 'origin/${{ env.LATEST_BRANCH }}'."
                echo "LATEST_UPDATED=false" >> $GITHUB_ENV
                exit 1
              fi
            fi

          else
            echo "Error: Tag ${{ env.LATEST_TAG }} commit could not be resolved after fetching from upstream."
            echo "LATEST_UPDATED=false" >> $GITHUB_ENV
            exit 1
          fi

      - name: Rebase feature branches to stable release
        if: env.LATEST_TAG != '' && env.LATEST_UPDATED == 'true'
        run: |
          TARGET_COMMIT=$(git rev-parse "refs/tags/${{ env.LATEST_TAG }}^{commit}")
          echo "Rebasing feature branches to commit: $TARGET_COMMIT (branch: ${{ env.LATEST_BRANCH }})"

          # Initialize result variables
          echo "REBASE_FAILED=false" >> $GITHUB_ENV
          FAILED_BRANCHES=""

          # Fetch all remote branches from origin
          git fetch origin --quiet

          # List all remote branches starting with FEATURE_BRANCH_PREFIX
          FEATURE_BRANCHES=$(git branch -r | grep "origin/${{ env.FEATURE_BRANCH_PREFIX }}" | sed 's|origin/||')

          if [ -z "$FEATURE_BRANCHES" ]; then
            echo "No feature branches starting with '${{ env.FEATURE_BRANCH_PREFIX }}' found."
            echo "REBASE_FAILED=true" >> $GITHUB_ENV
            exit 0
          fi

          echo "Found feature branches: $FEATURE_BRANCHES"

          # Loop through each feature branch and rebase it to TARGET_COMMIT
          for branch in $FEATURE_BRANCHES; do
            echo "Processing branch: $branch"

            # Clean up any uncommitted changes before switching or rebasing
            git reset --hard 2>/dev/null || true
            git clean -fd 2>/dev/null || true

            # Checkout the branch locally
            if git checkout "$branch"; then
              # Rebase the branch onto TARGET_COMMIT
              if git rebase "$TARGET_COMMIT"; then
                echo "Successfully rebased $branch onto $TARGET_COMMIT"
                # Force push the rebased branch to remote
                if git push --force origin "$branch"; then
                  echo "Successfully pushed rebased branch $branch to remote"
                else
                  echo "Error: Failed to push rebased branch $branch to remote"
                  FAILED_BRANCHES="$FAILED_BRANCHES $branch (push failed)"
                  echo "REBASE_FAILED=true" >> $GITHUB_ENV
                fi
              else
                echo "Rebase failed for $branch. Creating an issue for manual intervention."
                git rebase --abort
                FAILED_BRANCHES="$FAILED_BRANCHES $branch (rebase conflict)"
                echo "REBASE_FAILED=true" >> $GITHUB_ENV
                # Create an issue for conflict resolution
                ISSUE_TITLE="Rebase Conflict for branch $branch"
                ISSUE_BODY="Rebase of branch $branch onto commit $TARGET_COMMIT failed due to conflicts. Please resolve manually.\n\n- Branch: $branch\n- Target Commit: $TARGET_COMMIT\n- Workflow Run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                curl -X POST \
                  -H "Authorization: token ${{ secrets.PAT_TOKEN }}" \
                  -H "Accept: application/vnd.github.v3+json" \
                  -d "{\"title\": \"$ISSUE_TITLE\", \"body\": \"$ISSUE_BODY\"}" \
                  "https://api.github.com/repos/${{ github.repository }}/issues"
              fi
            else
              echo "Error: Failed to checkout $branch"
              FAILED_BRANCHES="$FAILED_BRANCHES $branch (checkout failed)"
              echo "REBASE_FAILED=true" >> $GITHUB_ENV
            fi
          done

          # Summary of failed branches
          if [ -n "$FAILED_BRANCHES" ]; then
            echo "Rebase process completed with failures for the following branches:$FAILED_BRANCHES"
            echo "Finished rebasing all feature branches."
            exit 1
          else
            echo "Rebase process completed successfully for all branches."
            echo "Finished rebasing all feature branches."
            exit 0
          fi
